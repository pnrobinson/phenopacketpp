
#include "jsonobo.h"


#include "rapidjson/writer.h"
#include "rapidjson/stringbuffer.h"
#include <rapidjson/istreamwrapper.h>
#include <rapidjson/prettywriter.h>

#include <iostream>
#include <fstream>
#include <sstream>

using std::cout;

/**
 * A convenience function for debugging only!
 */
void
printJ(const rapidjson::Value &json)
{
  using namespace rapidjson;
  StringBuffer sb;
  PrettyWriter<StringBuffer> writer(sb);
  json.Accept(writer);
  auto str = sb.GetString();
  std::cout << str << "\n";
}

/**
 * generate a printable String from an arbitrary RAPIDJSON value object.
 * Used mainly to create error messages (if any)
 * @param json A rapid json object
 * @return a String representation of the JSON.
 */
string get_json_string(const rapidjson::Value &json)
{
  using namespace rapidjson;
  StringBuffer sb;
  PrettyWriter<StringBuffer> writer(sb);
  json.Accept(writer);
  return sb.GetString();
}




bool is_class(const rapidjson::Value &val){
  if (! val.IsObject()) {
    return false;
  }
  if (! val.HasMember("type")) {
    return false;
  } else if (! strcmp(val["type"].GetString(), "CLASS")) {
    return true;
  }
  return false;
}

bool is_property(const rapidjson::Value &val){
  if (! val.IsObject()) {
    return false;
  }
  if (! val.HasMember("type")) {
    return false;
  } else if (! strcmp(val["type"].GetString(), "PROPERTY")) {
    return true;
  }
  return false;
}

void
JsonOboParser::process_metadata(const rapidjson::Value &val){
  if (! val.IsObject()) {
    throw JsonParseException("Attempt to add malformed meta (not JSON object).");
  }
  auto itr = val.FindMember("basicPropertyValues");
  if (itr != val.MemberEnd()) {
    const rapidjson::Value &propertyVals = itr->value;
    if (! propertyVals.IsArray()) {
      throw JsonParseException("Ontology property values not array");
    }
    for (auto elem = propertyVals.Begin(); elem != propertyVals.End(); elem++) {
      PropertyValue propval = PropertyValue::of(*elem);
      property_value_list_.push_back(propval);
      ontology_.add_property_value(propval);
    }
  }
}

void
JsonOboParser::process_nodes(const rapidjson::Value& nodes)
{
  if (! nodes.IsArray()) {
    throw JsonParseException("rapidjson nodes object is not array");
  }
  string myError;
  int n=0;
  for (auto& v : nodes.GetArray()) {
    if (is_class(v)) {
      try {
	       Term term = Term::of(v);
	       term_list_.push_back(term);
	       n++;
	       //cout << "\n" << n << std::flush;
      } catch (const JsonParseException& e) {
	       string json_stanza = get_json_string(v);
         string message = e.what();
         std::stringstream sstr;
         sstr << "[ERROR] " << e.what() << "; generated by ("
              << get_json_string(v);
         error_list_.push_back(sstr.str());
        }
    } else if (is_property(v)){
      try{
	       Property prop = Property::of(v);
	       ontology_.add_property(prop);
      } catch (const JsonParseException& e) {
         std::stringstream sstr;
         sstr << "[ERROR] Could not create Node" << e.what() << "; generated by ("
              << get_json_string(v);
         error_list_.push_back(sstr.str());
      }
    } else {
      std::cerr << "[ERROR] Neither node nor property: ";
      printJ(v);
      exit(1);
    }
  }
}

void
JsonOboParser::process_edges(const rapidjson::Value& edges)
{
  if (! edges.IsArray()) {
    throw JsonParseException("rapidjson edges object is not array");
  }
  for (auto& v : edges.GetArray()) {
    try {
        Edge e = Edge::of(v);
        edge_list_.push_back(e);
    } catch (const JsonParseException& e) {
      std::stringstream sstr;
      sstr << "[ERROR] Could not create Edge: " << e.what() << "; generated by ("
           << get_json_string(v);
      error_list_.push_back(sstr.str());
    }
  }
}

JsonOboParser::JsonOboParser(const string path):
  path_(path) {
  rapidjson::Document d;
  std::cout << "[INFO] Parsing " << path_ << "\n";
  std::ifstream ifs(path_);
  rapidjson::IStreamWrapper isw(ifs);

  d.ParseStream(isw);
  const rapidjson::Value& a = d["graphs"];
  if (! a.IsArray()) {
    throw JsonParseException("Ontology JSON did not contain graphs element array.");
  }
  // the first item in the array is an object with a list of nodes
  if( a.Size() < 1){
    throw JsonParseException("Ontology JSON did not contain array of nodes.");
  }
  const rapidjson::Value& mainObject = a[0];
  if ( ! mainObject.IsObject()) {
    throw JsonParseException("Main object was not a rapidjson object.");
  }
  const rapidjson::Value& nodes = mainObject["nodes"];
  process_nodes(nodes);

  string myError;
  rapidjson::Value::ConstMemberIterator itr = mainObject.FindMember("edges");
  if (itr == mainObject.MemberEnd()){
    throw JsonParseException("Did not find edges element");
  }
  const rapidjson::Value& edges = mainObject["edges"];
  process_edges(edges);


  itr = mainObject.FindMember("id");
  if (itr == mainObject.MemberEnd()){
    throw JsonParseException("Did not find id element");
  } else {
    ontology_id_ = itr->value.GetString();
  }
  itr = mainObject.FindMember("meta");
  if (itr == mainObject.MemberEnd()){
    throw JsonParseException("Did not find meta element");
  } else {
    const rapidjson::Value& meta = mainObject["meta"];
    process_metadata(meta);
  }
  std::cout << "DONE:" <<  std::endl;
  if (error_list_.size()>0) {
    for (string e : error_list_) {
      std::cout << "\t" << e << "\n";
    }
  } else {
    std::cout << "[INFO] No errors encountered\n";
  }
}




void
JsonOboParser::transform_input_data_to_ontology()
{
vector<int> offset_e_;

}

void
JsonOboParser::dump_errors() const
{
  if (error_list_.size() == 0) {
    std::cout <<"[INFO] No errors enounted in JSON parse\n";
    return;
  }
  std::cout << "[ERRORS]:\n";
  for (string e : error_list_) {
    std::cout << e << "\n";
  }
}


Ontology
JsonOboParser::get_ontology()
{
  dump_errors();
  ontology_.set_id(ontology_id_);
  ontology_.add_all_terms(term_list_);
  ontology_.add_all_edges(edge_list_);
  return ontology_;
}
